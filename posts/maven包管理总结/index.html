<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Tdd的博客  | Maven包管理总结</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.58.3" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="Maven包管理总结" />
<meta property="og:description" content=" Maven是java开发者的福音，从手动敲命令到Mavne的自动化构建，java从繁琐走向简单，但这样的变化并不是百利而无一害，自动化构建带来的是自主选择的减少，而且Maven对于包冲突以及传递性依赖的解决机制并不能总是让人满意。今天就来简单总结一下其中的几个困难。 Java包管理 包和classpath java的包管理就是告诉JVM第三方类库所在位置和解决冲突的过程
 不用于java中用于解决类名冲突和访问控制的包，这里指由一堆相互关联的类经过编译所生成字节码.class集合的jar包 classpath用来为JVM指明所能执行字节码文件所在位置 传递性依赖，你依赖的类又依赖了别的类，全限定类名是类的唯一标识，当多个同名类出现在一个classpath中就会造成灾难-Classpath hell
Maven包管理 项目结构 约定优于配置
Maven的包 按照约定为所有的包编号，⽅便检索 groupId/artifactId/version，语义化版本
 默认的Maven中央仓库中存放着世界上所有的几乎所有的包，并按照约定的目录存放
 Maven在引入一个包后会根据这个包的pom.xml文件中的依赖引入所需要的所有包，直到没有可引入的包为止，这就是Maven的传递性依赖
 项目中所需的包会自动下载到本地.m2仓库中
包冲突的解决 常见的包冲突会引发的异常 AbstractMethodError NoClassDefFoundError ClassNotFoundException LinkageError   传递性依赖的⾃动管理  原则：绝对不允许最终的classpath出现同名不同版本的jar包 依赖冲突的解决：原则：最近的胜出  依赖的scope 指定依赖所有效的域，隔离第三方依赖
 compile: test和生产代码中都可以使用 test：只能在测试代码中使用 provided: 只在编译时有效  手动解决包冲突的过程(以&hellip;/hcsp/resolve-package-conflict为例)  首先查看项目的依赖结构，有三种方法：  找到项目的maven模块，点击Dependencies  命令行mvn dependency:tree(解决冲突后的树结构)  使用插件Maven Helper   分析出现冲突所在的包，并去中央仓库查看对应类的源代码 根据编译器提示抛出异常位置及插件所示冲突可知org.springframework.spring-web出现了冲突，进入中央仓库找到项目源代码所在位置 定位到所处问题的类中 经过对比发现5.1.8版本中没有getJsonpFunction()方法  手动解决冲突
 利用标签删除传递性依赖 将所需要的包声名在项目pom.xml中，根据maven包管理规则使之成为被依赖的包  Maven——⾃动化构建⼯具 祥见Maven实战
  " />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/maven%E5%8C%85%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/" />
<meta property="article:published_time" content="2019-10-03T06:49:31+08:00" />
<meta property="article:modified_time" content="2019-10-03T06:49:31+08:00" />
<meta itemprop="name" content="Maven包管理总结">
<meta itemprop="description" content=" Maven是java开发者的福音，从手动敲命令到Mavne的自动化构建，java从繁琐走向简单，但这样的变化并不是百利而无一害，自动化构建带来的是自主选择的减少，而且Maven对于包冲突以及传递性依赖的解决机制并不能总是让人满意。今天就来简单总结一下其中的几个困难。 Java包管理 包和classpath java的包管理就是告诉JVM第三方类库所在位置和解决冲突的过程
 不用于java中用于解决类名冲突和访问控制的包，这里指由一堆相互关联的类经过编译所生成字节码.class集合的jar包 classpath用来为JVM指明所能执行字节码文件所在位置 传递性依赖，你依赖的类又依赖了别的类，全限定类名是类的唯一标识，当多个同名类出现在一个classpath中就会造成灾难-Classpath hell
Maven包管理 项目结构 约定优于配置
Maven的包 按照约定为所有的包编号，⽅便检索 groupId/artifactId/version，语义化版本
 默认的Maven中央仓库中存放着世界上所有的几乎所有的包，并按照约定的目录存放
 Maven在引入一个包后会根据这个包的pom.xml文件中的依赖引入所需要的所有包，直到没有可引入的包为止，这就是Maven的传递性依赖
 项目中所需的包会自动下载到本地.m2仓库中
包冲突的解决 常见的包冲突会引发的异常 AbstractMethodError NoClassDefFoundError ClassNotFoundException LinkageError   传递性依赖的⾃动管理  原则：绝对不允许最终的classpath出现同名不同版本的jar包 依赖冲突的解决：原则：最近的胜出  依赖的scope 指定依赖所有效的域，隔离第三方依赖
 compile: test和生产代码中都可以使用 test：只能在测试代码中使用 provided: 只在编译时有效  手动解决包冲突的过程(以&hellip;/hcsp/resolve-package-conflict为例)  首先查看项目的依赖结构，有三种方法：  找到项目的maven模块，点击Dependencies  命令行mvn dependency:tree(解决冲突后的树结构)  使用插件Maven Helper   分析出现冲突所在的包，并去中央仓库查看对应类的源代码 根据编译器提示抛出异常位置及插件所示冲突可知org.springframework.spring-web出现了冲突，进入中央仓库找到项目源代码所在位置 定位到所处问题的类中 经过对比发现5.1.8版本中没有getJsonpFunction()方法  手动解决冲突
 利用标签删除传递性依赖 将所需要的包声名在项目pom.xml中，根据maven包管理规则使之成为被依赖的包  Maven——⾃动化构建⼯具 祥见Maven实战
  ">


<meta itemprop="datePublished" content="2019-10-03T06:49:31&#43;08:00" />
<meta itemprop="dateModified" content="2019-10-03T06:49:31&#43;08:00" />
<meta itemprop="wordCount" content="49">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Maven包管理总结"/>
<meta name="twitter:description" content=" Maven是java开发者的福音，从手动敲命令到Mavne的自动化构建，java从繁琐走向简单，但这样的变化并不是百利而无一害，自动化构建带来的是自主选择的减少，而且Maven对于包冲突以及传递性依赖的解决机制并不能总是让人满意。今天就来简单总结一下其中的几个困难。 Java包管理 包和classpath java的包管理就是告诉JVM第三方类库所在位置和解决冲突的过程
 不用于java中用于解决类名冲突和访问控制的包，这里指由一堆相互关联的类经过编译所生成字节码.class集合的jar包 classpath用来为JVM指明所能执行字节码文件所在位置 传递性依赖，你依赖的类又依赖了别的类，全限定类名是类的唯一标识，当多个同名类出现在一个classpath中就会造成灾难-Classpath hell
Maven包管理 项目结构 约定优于配置
Maven的包 按照约定为所有的包编号，⽅便检索 groupId/artifactId/version，语义化版本
 默认的Maven中央仓库中存放着世界上所有的几乎所有的包，并按照约定的目录存放
 Maven在引入一个包后会根据这个包的pom.xml文件中的依赖引入所需要的所有包，直到没有可引入的包为止，这就是Maven的传递性依赖
 项目中所需的包会自动下载到本地.m2仓库中
包冲突的解决 常见的包冲突会引发的异常 AbstractMethodError NoClassDefFoundError ClassNotFoundException LinkageError   传递性依赖的⾃动管理  原则：绝对不允许最终的classpath出现同名不同版本的jar包 依赖冲突的解决：原则：最近的胜出  依赖的scope 指定依赖所有效的域，隔离第三方依赖
 compile: test和生产代码中都可以使用 test：只能在测试代码中使用 provided: 只在编译时有效  手动解决包冲突的过程(以&hellip;/hcsp/resolve-package-conflict为例)  首先查看项目的依赖结构，有三种方法：  找到项目的maven模块，点击Dependencies  命令行mvn dependency:tree(解决冲突后的树结构)  使用插件Maven Helper   分析出现冲突所在的包，并去中央仓库查看对应类的源代码 根据编译器提示抛出异常位置及插件所示冲突可知org.springframework.spring-web出现了冲突，进入中央仓库找到项目源代码所在位置 定位到所处问题的类中 经过对比发现5.1.8版本中没有getJsonpFunction()方法  手动解决冲突
 利用标签删除传递性依赖 将所需要的包声名在项目pom.xml中，根据maven包管理规则使之成为被依赖的包  Maven——⾃动化构建⼯具 祥见Maven实战
  "/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://example.org/" class="f3 fw2 hover-white no-underline white-90 dib">
      Tdd的博客
    </a>
    <div class="flex-l items-center">
      

      
      











    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">Maven包管理总结</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2019-10-03T06:49:31&#43;08:00">October 3, 2019</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<h1 id="maven是java开发者的福音-从手动敲命令到mavne的自动化构建-java从繁琐走向简单-但这样的变化并不是百利而无一害-自动化构建带来的是自主选择的减少-而且maven对于包冲突以及传递性依赖的解决机制并不能总是让人满意-今天就来简单总结一下其中的几个困难">Maven是java开发者的福音，从手动敲命令到Mavne的自动化构建，java从繁琐走向简单，但这样的变化并不是百利而无一害，自动化构建带来的是自主选择的减少，而且Maven对于包冲突以及传递性依赖的解决机制并不能总是让人满意。今天就来简单总结一下其中的几个困难。</h1>

<hr />

<h2 id="java包管理">Java包管理</h2>

<h3 id="包和classpath">包和classpath</h3>

<p>java的包管理就是告诉JVM第三方类库所在位置和解决冲突的过程</p>

<ul>
<li>不用于java中用于解决类名冲突和访问控制的包，这里指由一堆相互关联的类经过编译所生成字节码<code>.class</code>集合的jar包</li>
<li>classpath用来为JVM指明所能执行字节码文件所在位置</li>

<li><p>传递性依赖，你依赖的类又依赖了别的类，全限定类名是类的唯一标识，当多个同名类出现在一个classpath中就会造成灾难-Classpath hell</p>

<hr />

<h2 id="maven包管理">Maven包管理</h2>

<h3 id="项目结构">项目结构</h3></li>

<li><p>约定优于配置</p>

<h3 id="maven的包">Maven的包</h3></li>

<li><p>按照约定为所有的包编号，⽅便检索
groupId/artifactId/version，语义化版本</p></li>

<li><p>默认的Maven中央仓库中存放着世界上所有的几乎所有的包，并按照约定的目录存放</p></li>

<li><p>Maven在引入一个包后会根据这个包的<code>pom.xml</code>文件中的依赖引入所需要的所有包，直到没有可引入的包为止，这就是Maven的传递性依赖</p></li>

<li><p>项目中所需的包会自动下载到本地.m2仓库中</p>

<hr />

<h2 id="包冲突的解决">包冲突的解决</h2>

<h3 id="常见的包冲突会引发的异常">常见的包冲突会引发的异常</h3>

<pre><code>AbstractMethodError
NoClassDefFoundError
ClassNotFoundException
LinkageError
</code></pre></li>
</ul>

<h3 id="传递性依赖的-动管理">传递性依赖的⾃动管理</h3>

<ul>
<li>原则：绝对不允许最终的classpath出现同名不同版本的jar包</li>
<li>依赖冲突的解决：原则：最近的胜出</li>
</ul>

<h3 id="依赖的scope">依赖的scope</h3>

<p>指定依赖所有效的域，隔离第三方依赖</p>

<ul>
<li>compile: test和生产代码中都可以使用</li>
<li>test：只能在测试代码中使用</li>
<li>provided: 只在编译时有效</li>
</ul>

<h3 id="手动解决包冲突的过程-以-hcsp-resolve-package-conflict为例">手动解决包冲突的过程(以&hellip;/hcsp/resolve-package-conflict为例)</h3>

<ol>
<li>首先查看项目的依赖结构，有三种方法：

<ul>
<li>找到项目的maven模块，点击Dependencies
<img src="/images/MavenPackagemanagement/1.png" alt="模块" /></li>
<li>命令行mvn dependency:tree(解决冲突后的树结构)
<img src="/images/MavenPackagemanagement/3.png" alt="command line" /></li>
<li>使用插件Maven Helper
<img src="/images/MavenPackagemanagement/2.png" alt="插件图片" /></li>
</ul></li>

<li><p>分析出现冲突所在的包，并去中央仓库查看对应类的源代码
<img src="/images/MavenPackagemanagement/4.png" alt="exception" /></p>

<p><img src="/images/MavenPackagemanagement/5.png" alt="analyzer" />
根据编译器提示抛出异常位置及插件所示冲突可知org.springframework.spring-web出现了冲突，进入中央仓库找到项目源代码所在位置
<img src="/images/MavenPackagemanagement/6.png" alt="" /></p>

<p>定位到所处问题的类中
<img src="/images/MavenPackagemanagement/5.1.8.png" alt="" /></p>

<p><img src="/images/MavenPackagemanagement/4.3.6.png" alt="" />
经过对比发现5.1.8版本中没有getJsonpFunction()方法
<img src="/images/MavenPackagemanagement/8.png" alt="" /></p>

<p><img src="/images/MavenPackagemanagement/7.png" alt="" /></p></li>

<li><p>手动解决冲突</p>

<ul>
<li>利用<exclusion>标签删除传递性依赖</li>
<li>将所需要的包声名在项目pom.xml中，根据maven包管理规则使之成为被依赖的包</li>
</ul>

<p><img src="/images/MavenPackagemanagement/9.png" alt="" /></p>

<h2 id="maven-动化构建-具">Maven——⾃动化构建⼯具</h2></li>

<li><p>祥见Maven实战</p></li>
</ol>
<ul class="pa0">
  
</ul>
<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://example.org/" >
    &copy; 2019 Tdd的博客
  </a>
    <div>










</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
